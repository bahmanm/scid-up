package require tcltest 2.5
namespace import ::tcltest::*

source [file join [file dirname [file dirname [info script]]] _support support.tcl]

# Ensure namespaces exist prior to sourcing the module under test.
namespace eval ::gbrowser {}
namespace eval ::board {}

# Source the module under test.
source [file join [::scid_test::tclDir] windows browser.tcl]

namespace eval ::browser_test {
    variable stubbedCommands {}

    variable boardUpdateCalls {}
    variable boardFlipCalls {}
    variable updateCalls {}
    variable afterCalls {}

    variable textCalls
    array set textCalls {}

    variable textTagRanges
    array set textTagRanges {}
}

proc ::browser_test::stubCommand {name argList body} {
    variable stubbedCommands
    ::scid_test::mocks::stubCommand stubbedCommands $name $argList $body
}

proc ::browser_test::restoreStubs {} {
    variable stubbedCommands
    ::scid_test::mocks::restoreStubs stubbedCommands
}

proc ::browser_test::defineTextWidget {path} {
    if {[llength [info commands $path]]} {
        error "Text widget command already exists: $path"
    }

    set ::browser_test::textCalls($path) {}
    interp alias {} $path {} ::browser_test::dispatchTextWidget $path
    return $path
}

proc ::browser_test::dispatchTextWidget {path subcmd args} {
    if {$subcmd ne "tag"} {
        lappend ::browser_test::textCalls($path) [list $subcmd {*}$args]
    }

    switch -- $subcmd {
        configure {
            return
        }
        see {
            return
        }
        tag {
            set tagSubcmd [lindex $args 0]
            set tagArgs [lrange $args 1 end]

            lappend ::browser_test::textCalls($path) [list tag:$tagSubcmd {*}$tagArgs]

            switch -- $tagSubcmd {
                nextrange {
                    set tag [lindex $tagArgs 0]
                    set key "$path,$tag"
                    if {[info exists ::browser_test::textTagRanges($key)]} {
                        return $::browser_test::textTagRanges($key)
                    }
                    return {}
                }
                remove -
                add -
                configure -
                bind -
                names -
                delete {
                    return {}
                }
                default {
                    error "Text widget $path tag subcommand $tagSubcmd not stubbed"
                }
            }
        }
        default {
            error "Text widget $path subcommand $subcmd not stubbed"
        }
    }
}

proc ::browser_test::setup {} {
    ::browser_test::restoreStubs
    ::scid_test::widgets::reset

    set ::browser_test::boardUpdateCalls {}
    set ::browser_test::boardFlipCalls {}
    set ::browser_test::updateCalls {}
    set ::browser_test::afterCalls {}

    catch {array unset ::browser_test::textCalls}
    array set ::browser_test::textCalls {}

    catch {array unset ::browser_test::textTagRanges}
    array set ::browser_test::textTagRanges {}

    catch {array unset ::gbrowser::boards}
    catch {array unset ::gbrowser::ply}
    catch {array unset ::gbrowser::autoplay}

    set ::gbrowser::autoplay(0) 0

    if {![info exists ::autoplayDelay]} {
        set ::autoplayDelay 250
    }

    ::browser_test::stubCommand ::board::update {widget board show} {
        lappend ::browser_test::boardUpdateCalls [list $widget $board $show]
        return
    }

    ::browser_test::stubCommand ::board::flip {widget} {
        lappend ::browser_test::boardFlipCalls $widget
        return
    }


    ::browser_test::stubCommand after {args} {
        lappend ::browser_test::afterCalls $args
        return
    }

    ::browser_test::stubCommand winfo {subcmd arg} {
        if {$subcmd ne "exists"} {
            error "winfo $subcmd not stubbed in browser tests"
        }
        if {$arg eq ".gb0"} {
            return 1
        }
        return 0
    }

    ::browser_test::defineTextWidget .gb0.t.text
    ::scid_test::widgets::defineWidget .gb0.b.autoplay
}

proc ::browser_test::cleanup {} {
    ::browser_test::restoreStubs
    ::scid_test::widgets::reset

    catch {rename .gb0.t.text ""}

    catch {array unset ::gbrowser::boards}
    catch {array unset ::gbrowser::ply}
    catch {array unset ::gbrowser::autoplay}
}

# ---- Tests ----

test browser-mousewheelHandler-delegates-to-update-1.0 {mousewheelHandler maps wheel direction to update offsets} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::browser_test::updateCalls {}

    ::browser_test::stubCommand ::gbrowser::update {n ply} {
        lappend ::browser_test::updateCalls [list $n $ply]
        return
    }

    # Act
    ::gbrowser::mousewheelHandler 3 -1
    ::gbrowser::mousewheelHandler 3 1

    # Assert
    set ::browser_test::updateCalls
} -cleanup {
    ::browser_test::cleanup
} -result {{3 -1} {3 +1}}


test browser-flip-calls-board-flip-1.0 {flip delegates to board::flip for the browser board widget} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::browser_test::boardFlipCalls {}

    # Act
    ::gbrowser::flip 0

    # Assert
    set ::browser_test::boardFlipCalls
} -cleanup {
    ::browser_test::cleanup
} -result {.gb0.bd}


test browser-update-noop-when-window-missing-1.0 {update returns immediately when the browser window does not exist} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    ::browser_test::stubCommand winfo {subcmd arg} {
        if {$subcmd ne "exists"} {
            error "winfo $subcmd not stubbed in browser tests"
        }
        return 0
    }

    set ::gbrowser::boards(0) {b0 b1}
    set ::browser_test::boardUpdateCalls {}

    # Act
    ::gbrowser::update 0 0

    # Assert
    list [info exists ::gbrowser::ply(0)] $::browser_test::boardUpdateCalls
} -cleanup {
    ::browser_test::cleanup
} -result {0 {}}


test browser-update-normalises-and-clamps-ply-1.0 {update normalises symbolic ply values and clamps within bounds} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    ::browser_test::stubCommand winfo {subcmd arg} {
        if {$subcmd ne "exists"} {
            error "winfo $subcmd not stubbed in browser tests"
        }
        if {$arg eq ".gb0"} {
            return 1
        }
        return 0
    }

    set ::gbrowser::boards(0) {b0 b1 b2}

    # Act
    set ::gbrowser::ply(0) 1
    ::gbrowser::update 0 forward
    set p1 $::gbrowser::ply(0)

    ::gbrowser::update 0 back
    set p2 $::gbrowser::ply(0)

    ::gbrowser::update 0 start
    set p3 $::gbrowser::ply(0)

    ::gbrowser::update 0 end
    set p4 $::gbrowser::ply(0)

    set ::gbrowser::ply(0) 0
    ::gbrowser::update 0 -1
    set p5 $::gbrowser::ply(0)

    set ::gbrowser::ply(0) 1
    ::gbrowser::update 0 +10
    set p6 $::gbrowser::ply(0)

    # Assert
    list \
        $p1 $p2 $p3 $p4 $p5 $p6 \
        [lmap call $::browser_test::boardUpdateCalls {lindex $call 1}]
} -cleanup {
    ::browser_test::cleanup
} -result {2 1 0 2 0 2 {b2 b1 b0 b2 b0 b2}}


test browser-update-highlights-current-move-tag-1.0 {update highlights the current move tag and scrolls it into view when ranges exist} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::gbrowser::boards(0) {b0 b1}
    set ::gbrowser::ply(0) 0

    set ::browser_test::textTagRanges(.gb0.t.text,m1) {3.0 3.2}
    set ::browser_test::textCalls(.gb0.t.text) {}

    # Act
    ::gbrowser::update 0 1

    # Assert
    set calls $::browser_test::textCalls(.gb0.t.text)
    set hasAdd [expr {[lsearch -exact $calls {tag:add next 3.0 3.2}] >= 0}]
    set hasSee [expr {[lsearch -exact $calls {see 3.0}] >= 0}]
    list $hasAdd $hasSee
} -cleanup {
    ::browser_test::cleanup
} -result {1 1}


test browser-update-oldply-defaults-to-zero-1.0 {update uses oldply 0 when the prior ply is unset} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    catch {unset ::gbrowser::ply(0)}

    set ::gbrowser::boards(0) {b0 b1 b2}
    set ::browser_test::boardUpdateCalls {}

    # Act
    ::gbrowser::update 0 forward

    # Assert
    list $::gbrowser::ply(0) $::browser_test::boardUpdateCalls
} -cleanup {
    ::browser_test::cleanup
} -result {1 {{.gb0.bd b1 1}}}


test browser-update-toggles-text-state-and-clears-highlight-1.0 {update toggles the text state and clears the current highlight} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::gbrowser::boards(0) {b0 b1}
    set ::gbrowser::ply(0) 0

    set ::browser_test::textCalls(.gb0.t.text) {}

    # Act
    ::gbrowser::update 0 1

    # Assert
    set calls $::browser_test::textCalls(.gb0.t.text)

    set idxNormal [lsearch -exact $calls {configure -state normal}]
    set idxRemove [lsearch -exact $calls {tag:remove next 1.0 end}]
    set idxDisabled [lsearch -exact $calls {configure -state disabled}]

    list \
        [expr {$idxNormal >= 0}] \
        [expr {$idxRemove >= 0}] \
        [expr {$idxDisabled >= 0}] \
        [expr {$idxNormal < $idxRemove && $idxRemove < $idxDisabled}]
} -cleanup {
    ::browser_test::cleanup
} -result {1 1 1 1}


test browser-update-autoplay-schedules-next-move-1.0 {update schedules the next move when autoplay is enabled and not at end} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::gbrowser::boards(0) {b0 b1 b2}
    set ::gbrowser::autoplay(0) 1
    set ::autoplayDelay 123

    set ::browser_test::afterCalls {}

    # Act
    ::gbrowser::update 0 0

    # Assert
    set ::browser_test::afterCalls
} -cleanup {
    ::browser_test::cleanup
} -result {{cancel {::gbrowser::update 0 +1}} {123 {::gbrowser::update 0 +1}}}


test browser-update-autoplay-stops-at-end-1.0 {update disables autoplay when the end of the game is reached} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    ::browser_test::stubCommand ::gbrowser::autoplay {n} {
        lappend ::browser_test::updateCalls [list autoplay $n]
        return
    }

    set ::gbrowser::boards(0) {b0 b1 b2}
    set ::gbrowser::ply(0) 2
    set ::gbrowser::autoplay(0) 1

    set ::browser_test::afterCalls {}
    set ::browser_test::updateCalls {}

    # Act
    ::gbrowser::update 0 2

    # Assert
    list $::browser_test::updateCalls $::browser_test::afterCalls
} -cleanup {
    ::browser_test::cleanup
} -result {{{autoplay 0}} {}}


test browser-autoplay-toggle-updates-button-image-1.0 {autoplay toggles state, updates button image, and triggers update when enabling} -setup {
    ::browser_test::setup
} -body {
    # Arrange
    set ::browser_test::updateCalls {}
    set ::gbrowser::autoplay(0) 0

    ::browser_test::stubCommand ::gbrowser::update {n ply} {
        lappend ::browser_test::updateCalls [list $n $ply]
        return
    }

    # Act
    ::gbrowser::autoplay 0
    set enabled $::gbrowser::autoplay(0)
    set imgOn [::scid_test::widgets::getState .gb0.b.autoplay -image]

    ::gbrowser::autoplay 0
    set disabled $::gbrowser::autoplay(0)
    set imgOff [::scid_test::widgets::getState .gb0.b.autoplay -image]

    # Assert
    list $enabled $imgOn $disabled $imgOff $::browser_test::updateCalls
} -cleanup {
    ::browser_test::cleanup
} -result {1 tb_stop 0 tb_play {{0 +1}}}


cleanupTests
